---
title: 'Local Continuity Meta-criteria'
subtitle: 'Choosing the tuning parameters in Local MDS'
author: "Pedro Delicado"
date: "`r format(Sys.time(), '%d de %B de %Y')`"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval=TRUE, warning = FALSE, message = FALSE, comment = FALSE, error = FALSE)
#Put echo = FALSE, eval=FALSE for having just the question statements
#Put echo = TRUE, eval=TRUE for obtaining the output
```

## Local Continuity Meta-criteria

Chen and Buja (2009, JASA, Section 3) propose a criteria for tuning parameter selection in Local MDS: The *Local Continuity Meta-criteria* (or *LC meta-criteria*) that is also useful for other dimensionality reduction methods.

Following the notation used in the classes slides, for a neighborhood size $K'$ and for the $i$-th object $\mathcal{O}_i$ in the data set, let $N_{K'}(i)$ be the number of cases that simultaneously are between the $K'$-nearest neighbors of $\mathcal{O}_i$ in the high-dimensional space (distances here are $\delta_{ij}$), and between the $K'$-nearest neighbors of the mapped point $y_i$ in the low-dimensional configuration (distances here are $\|y_i-y_j\|$). Then define
\[
N_{K'}=\frac{1}{n}\sum_{i=1}^n N_{K'}(i) 
\]
as a global measure of overlapping between $K'$-nearest neighbors in both spaces, that could be called *local continuity*.
In order to normalize, 
\[
M_{K'}=\frac{1}{K'} N_{K'}
\]
is used instead of $N_{K'}$ ($M_{K'}$ is always in $[0,1]$). Even better is using the *adjusted LC meta-criteria* defined as
\[
M_{K'}^{adj}=M_{K'} - \frac{K'}{n-1},
\]
because $K'/(n-1)$ is the expected value of $M_{K'}$ under complete absence of association between the original data and the low-dimensional configuration. 

The following function computes $M_{K'}^{adj}$ as a function of two distance matrices between points (one being computed in the high-dimensional space, an the other being the Euclidean distance matrix in the low-dimensional configuration) and the value $K'$.

```{r}
LCMC <- function(D1,D2,Kp){
  D1 <- as.matrix(D1)
  D2 <- as.matrix(D2)
  n <- dim(D1)[1]
  N.Kp.i <- numeric(n)
  for (i in 1:n){
    N1.i <- sort.int(D1[i,],index.return = TRUE)$ix[1:Kp]
    N2.i <- sort.int(D2[i,],index.return = TRUE)$ix[1:Kp]
    N.Kp.i[i] <- length(intersect(N1.i, N2.i))
  }
  N.Kp<-mean(N.Kp.i)
  M.Kp.adj <- N.Kp/Kp - Kp/(n-1)
  
  return(list(N.Kp.i=N.Kp.i, M.Kp.adj=M.Kp.adj))
}
```

## Generating the dataset

We are working with a 3-dimensional data set generated around a 1-dimensional S-shape curve. We use the following code to generate the data.

```{r, echo=TRUE, eval=TRUE}
t <- seq(-1.5*pi,1.5*pi,l=100)
R<- 1
n<-75
sd.eps <- .15

set.seed(1)
y <- R*sign(t) - R*sign(t)*cos(t/R)
x <- -R*sin(t/R)
z <- (y/(2*R))^2
rt <- sort(runif(n)*3*pi - 1.5*pi)
eps <- rnorm(n)*sd.eps
ry <- R*sign(rt) - (R+eps)*sign(rt)*cos(rt/R)
rx <- -(R+eps)*sin(rt/R)
rz <- (ry/(2*R))^2 + runif(n,min=-2*sd.eps,max=2*sd.eps)
XYZ <- cbind(rx,ry,rz)

require(plot3D)
lines3D(x,y,z,colvar = NULL, 
         phi = 20, theta = 60, r =sqrt(3), d =3, scale=FALSE,
         col=2,lwd=4,as=1,
         xlim=range(rx),ylim=range(ry),zlim=range(rz))
points3D(rx,ry,rz,col=4,pch=19,cex=.6,add=TRUE)
```

## Choosing the tuning parameters in Local MDS

Local MDS depends on three tuning parameters:

* $K$, the number of nearest neighbors used to define the set of nearby pairs $\mathcal{N}_K$. 
* $\tau$, the unit-free parameter used to weight the contribution of large distances in the Local MDS Stress function.
* $q$, the dimension of the desired low-dimensional configuration.

Here we fix $q=1$. To fit Local MDS, we use the following code (already provided in the script `ex_localMDS_S.Rmd`). 

```{r}
# Local MDS. Implemented by Pedro Delicado, December 2020
#
# Objective function in Local MDS, eq (7) in Chen and Buja (2009)
Stress.LocalMDS <- function(conf,dist.orig,k=5,tau=1){
  require(smacof)
  ld <- length(dist.orig)
  n <- (1+sqrt(1+8*ld))/2
  q<-length(conf)/n
  mconf <- matrix(conf,nrow = n, byrow = FALSE) # configuration matrix
  Eucl.dist <- dist(mconf)
  w <- dissWeights(dist.orig, type = "knn", k = k)
  w.1 <- (w==1)
  card.N.k <- sum(w.1)
  card.N.k.c <- n*(n-1)/2 - card.N.k
  t <- (card.N.k/card.N.k.c)*median(dist.orig[w.1])*tau
  return(sum((dist.orig[w.1]-Eucl.dist[w.1])^2) - t*sum(Eucl.dist[!w.1]))
}

LocalMDS <- function(dist.orig,k=5,tau=1,q=2, maxit=1000){
  # dist.orig: Distance matrix (as a dist object) in the high-dim space 
  # k: Neighbors defining the N_k set of nearby pairs
  # tau: weight of the large distances part of the Stress function
  # q: Dimension of the low-dimensional configuration
  # maxit: Maximum number of iteration in the optim function
  conf0 <- as.numeric(cmdscale(dist.orig,k=q))
  n <-length(conf0)/q
  localMDS.res <- optim(par=conf0, fn=Stress.LocalMDS,
                          dist.orig=dist.orig, k=k, tau=tau,
                          method ="BFGS", control = list(maxit=maxit))
  conf.localMDS.res <- matrix(localMDS.res$par, nrow = n, byrow = FALSE)
  return(conf.localMDS.res)
}
```

**Choosing the pair $(K, \tau)$ maximizing the Local Continuity Meta-criteria.** 
We use $K'=10$ and restrict the search of $K$ to `c(5,10,15)` and $\tau$ to `c(.1,.5,1)`.
We use `maxit=20` when calling the R function `optim`.

```{r}
D1 <- dist(XYZ)
q <- 1
Kp <- 10

K <- c(5,10,15)
tau <- c(.1,.5,1)

LC <- matrix(0,nrow=length(K),ncol=length(tau))
LocalMDS.k.tau <- array(vector("list",1),dim=dim(LC))

for (i in 1:length(K)){
  for (j in 1:length(tau)){
    LocalMDS.k.tau[[i,j]] <- LocalMDS(D1, k=K[i], tau=tau[j],q=q, maxit=20)
    D2.k.tau <- dist(LocalMDS.k.tau[[i,j]])
    LC[i,j] <- LCMC(D1,D2.k.tau,Kp)$M.Kp.adj
    #print(c(i,j,LC[i,j]))
  }
}

ij.max <- arrayInd(which.max(LC),.dim=dim(LC))
k.max <- K[ij.max[1]] 
tau.max <- tau[ij.max[2]] 
LocalMDS.max <- LocalMDS.k.tau[[ij.max[1],ij.max[2]]]

print(paste0("k.max=",k.max,"; tau.max=",tau.max))
```

**Graphical representation of the Local MDS output.**
For the optimal $K$ and $\tau$, the output of the Local MDS is a $q$-dimensional configuration, that is, a $n\times q$ matrix (in our case with $q=1$).

We have called  `LocalMDS.max` to this output. We can represent it graphically using the following instruction:

```{r}
pairs(cbind(XYZ,rt,locMDS=LocalMDS.max[,1]))
```

Alternative graphical representations of the Local MDS fit, `LocalMDS.max`, can be done using smoothing techniques:

```{r, fig.height=2,fig.width=7}
#install.packages("mgcv") # To perform spline smoothing
library(mgcv)

df.xyzts <- as.data.frame(cbind(XYZ,rt,locMDS=LocalMDS.max[,1]))
names(df.xyzts)
#[1] "rx" "ry" "rz" "rt" "s(locMDS)" 

smooth.x <- gam(rx~s(locMDS), data=df.xyzts)
smooth.y <- gam(ry~s(locMDS), data=df.xyzts)
smooth.z <- gam(rz~s(locMDS), data=df.xyzts)

summary(smooth.x)
summary(smooth.y)
summary(smooth.z)

op <- par(mfrow=c(1,3))
plot(smooth.x, residuals=TRUE, shade=TRUE, cex=4, main="x versus locMDS")
plot(smooth.y, residuals=TRUE, shade=TRUE, cex=4, main="y versus locMDS")
plot(smooth.z, residuals=TRUE, shade=TRUE, cex=4, main="z versus locMDS")
par(op)
```
Now we do similar plots by ourselves:

```{r, fig.height=2,fig.width=7} 
s.x <- smooth.x$fitted.values
s.y <- smooth.y$fitted.values
s.z <- smooth.z$fitted.values
locMDS <- LocalMDS.max[,1]

op <- par(mfrow=c(1,3))
plot(locMDS, rx, col=8, pch=19, cex=1, main="x versus locMDS")
lines(locMDS, s.x, col=1, lwd=2)
plot(locMDS, ry, col=8, pch=19, cex=1, main="y versus locMDS")
lines(locMDS, s.y, col=1, lwd=2)
plot(locMDS, rz, col=8, pch=19, cex=1, main="z versus locMDS")
lines(locMDS, s.z, col=1, lwd=2)
par(op)
```

We can add the nonlinear curve fitted by Local MDS to the 3-dimensional representation of the original data:

```{r}
require(plot3D)
lines3D(x,y,z,colvar = NULL, 
         phi = 20, theta = 60, r =sqrt(3), d =3, scale=FALSE,
         col=2,lwd=4,as=1,
         xlim=range(rx),ylim=range(ry),zlim=range(rz))
points3D(rx,ry,rz,col=4,pch=19,cex=.6,add=TRUE)
lines3D(s.x,s.y,s.z, col=1, lwd=4, add=TRUE)
```

And, finally, here you have a interactive 3-dimensional representation:
```{r}
require(rgl)
points3d(rx,ry,rz,col=4,size=10)
lines3d(x,y,z, col=2,lwd=4)
lines3d(s.x,s.y,s.z, col=1, lwd=4)
```