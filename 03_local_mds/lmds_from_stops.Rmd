---
title: "Function `lmds` from library `stops`"
author: "Pedro Delicado"
date: "`r format(Sys.time(), '%d/%b/%Y')`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r,echo=FALSE, eval=FALSE}
# Before January 2023
if (!require(stops, quietly=TRUE, warn.conflicts=FALSE)){
  install.packages("stops", repos="http://R-Forge.R-project.org",INSTALL_opts="--no-test-load")
}
```

Attaching library `stops` and asking for help on `lmds`:
```{r}
library(stops)
#help(lmds)
```

## Portion of S shape curve, with radious R, of length 2*pi with noise

```{r}
t <- seq(-1.5*pi,1.5*pi,l=100)
R<- 1
n<-75
sd.residuals <- .15
```

```{r, fig.asp=1}
# windows(width=5,height=5)
# pdf("ej_MDS_S.pdf",width=5,height=5,paper="special")
set.seed(1)
plot(0,0,type="n",xlab="",ylab="",axes=FALSE, asp=1,
#     main="Ilustraci?n Paso 1 de ISOMAP",
     xlim=c(-1-2*sd.residuals,1+2*sd.residuals),
     ylim=c(-2-2*sd.residuals,2+2*sd.residuals))

# S plot with points
y <- R*sign(t) - R*sign(t)*cos(t/R)
x <- -R*sin(t/R)
lines(x,y,col=2,lwd=2)
rt <- sort(runif(n)*3*pi - 1.5*pi)
eps <- rnorm(n)*sd.residuals
ry <- R*sign(rt) - (R+eps)*sign(rt)*cos(rt/R)
rx <- -(R+eps)*sin(rt/R)
points(rx,ry,col=1,pch=19,cex=.6)
XY <- cbind(rx,ry)
#lines(x,y,col=2,lwd=2)
```



```{r,fig.height=6}
distXY <- dist(XY)
n <- dim(XY)[1]

k <- 5
tau <- .05
q<-2 # 2-dim config

conf0 <- stats::cmdscale(distXY, k=q)

lmds.S.res <- lmds(as.matrix(distXY), init=conf0, ndim=q, k=k, tau=tau, itmax = 1000)
conf.lmds.S.res <- lmds.S.res$conf
  
# localMDS.S.res <- optim(par=as.numeric(conf0), 
#                         fn=Stress.LocalMDS, n=n,dist.orig=distXY,k=k,tau=tau,
#                         method ="BFGS", control = list(maxit=1000))
# conf.localMDS.S.res <- matrix(localMDS.S.res$par, nrow = n, byrow = FALSE)

op <- par(mfrow=c(2,1))
plot(conf.lmds.S.res,as=1, main=paste0("Local MDS, k=",k,", tau=",tau))
text(conf.lmds.S.res[,1],conf.lmds.S.res[,2],1:n,pos=3)
#
plot(conf.lmds.S.res[,1],rt)
par(op)
```

It seems that $q=1$ can be enough:
```{r}
k <- 5
tau <- .5#.05
q<-1 # 1-dim config
conf0 <- stats::cmdscale(distXY, k=1)
lmds.S.res <- lmds(as.matrix(distXY), init=conf0, ndim=q, k=k, tau=tau, itmax = 1000)
conf.lmds.S.res <- lmds.S.res$conf
```

```{r}
lambda <- conf.lmds.S.res[,1] #1-dimemsional configuration
plot(lambda,rep(0,n),#as=1,    
     main=paste0("Local MDS, k=",k,", tau=",tau),
     xlab="lambda (1-dimemsional configuration)",
     ylab="")
text(lambda,rep(0,n),1:n,pos=3,cex=.4)
```

The 1-dimensional configuration $\lambda$ given by Local MDS is a good recovery of the true underline 1-dimensional generating variable `rt`. The linear relation between $\lambda$ and `rt` is almost perfect:

```{r,fig.asp=1}
plot(lambda,rt, as=1)
```

Now we plot the 1-dimensional structure of the data obtained from Local MDS using smoothing techniques:

```{r,fig.height=8}
#install.packages("mgcv") # To perform spline smoothing
library(mgcv)
smooth.x <- gam(rx~s(lambda))
smooth.y <- gam(ry~s(lambda))

s.x <- smooth.x$fitted.values
s.y <- smooth.y$fitted.values

op <- par(mfrow=c(2,1))
plot(lambda,rx,col=8, pch=19, cex=1, main="x versus lambda")
lines(lambda, s.x, col=1, lwd=2)
plot(lambda,ry,col=8, pch=19, cex=1, main="y versus lambda")
lines(lambda, s.y, col=1, lwd=2)
par(op)
```
We add the nonlinear curve fitted by Local MDS to the 2-dimensional representation of the original data:

```{r}
A <- 2.6
plot(0,0,type="n",xlab="",ylab="",axes=FALSE,
     xlim=c(-1-2*sd.residuals,1+2*sd.residuals + 2*A),
     ylim=c(-2-2*sd.residuals,2+2*sd.residuals))

# S plot with points
lines(x,y,col=2,lwd=2)
points(rx,ry,col=8,pch=19,cex=.8)
lines(s.x,s.y,col=1,lwd=2)

legend(.75*A,.75*A,c("Observed points","True generating curve", "Estimated curve"),
       col=c(8,2,1), pch=c(19,NA,NA), lwd=c(NA,2,2), bty="n", cex=.8)
```

## Local Continuity Meta-criteria with `lmds`

The following function computes the adjusted local continuity Meta-criteria $M_{K'}^{adj}$ as a function of two distance matrices between points (one being computed in the high-dimensional space, an the other being the Euclidean distance matrix in the low-dimensional configuration) and the value $K'$.

```{r}
LCMC <- function(D1,D2,Kp){
  D1 <- as.matrix(D1)
  D2 <- as.matrix(D2)
  n <- dim(D1)[1]
  N.Kp.i <- numeric(n)
  for (i in 1:n){
    N1.i <- sort.int(D1[i,],index.return = TRUE)$ix[1:Kp]
    N2.i <- sort.int(D2[i,],index.return = TRUE)$ix[1:Kp]
    N.Kp.i[i] <- length(intersect(N1.i, N2.i))
  }
  N.Kp<-mean(N.Kp.i)
  M.Kp.adj <- N.Kp/Kp - Kp/(n-1)
  
  return(list(N.Kp.i=N.Kp.i, M.Kp.adj=M.Kp.adj))
}
```

### Generating the dataset

We are working with a 3-dimensional data set generated around a 1-dimensional S-shape curve. We use the following code to generate the data.

```{r, echo=TRUE, eval=TRUE}
t <- seq(-1.5*pi,1.5*pi,l=100)
R<- 1
n<-75
sd.eps <- .15

set.seed(1)
y <- R*sign(t) - R*sign(t)*cos(t/R)
x <- -R*sin(t/R)
z <- (y/(2*R))^2
rt <- sort(runif(n)*3*pi - 1.5*pi)
eps <- rnorm(n)*sd.eps
ry <- R*sign(rt) - (R+eps)*sign(rt)*cos(rt/R)
rx <- -(R+eps)*sin(rt/R)
rz <- (ry/(2*R))^2 + runif(n,min=-2*sd.eps,max=2*sd.eps)
XYZ <- cbind(rx,ry,rz)

require(plot3D)
lines3D(x,y,z,colvar = NULL, 
         phi = 20, theta = 60, r =sqrt(3), d =3, scale=FALSE,
         col=2,lwd=4,as=1,
         xlim=range(rx),ylim=range(ry),zlim=range(rz))
points3D(rx,ry,rz,col=4,pch=19,cex=.6,add=TRUE)
```

### Choosing the tuning parameters in Local MDS implemented in `lmds`

Local MDS depends on three tuning parameters:

* $K$, the number of nearest neighbors used to define the set of nearby pairs $\mathcal{N}_K$. 
* $\tau$, the unit-free parameter used to weight the contribution of large distances in the Local MDS Stress function.
* $q$, the dimension of the desired low-dimensional configuration.

Here we fix $q=1$. To fit Local MDS, we use funtion `lmds`from package `stops`. 

**Choosing the pair $(K, \tau)$ maximizing the Local Continuity Meta-criteria.** 
We use $K'=10$ and restrict the search of $K$ to `c(5,10,15)` and $\tau$ to `c(.1,.5,1)`.
We use `maxit=20` when calling the R function `optim`.

```{r}
D1 <- dist(XYZ)
q <- 1
Kp <- 10

conf0 <- stats::cmdscale(D1,k=q)

K <- c(5,10,15)
tau <- c(.1,.5,1)

LC <- matrix(0,nrow=length(K),ncol=length(tau))
lmds.k.tau <- array(vector("list",1),dim=dim(LC))

for (i in 1:length(K)){
  for (j in 1:length(tau)){
    lmds.k.tau[[i,j]] <- lmds(as.matrix(D1), init=conf0, 
                              ndim=q, k=K[i], tau=tau[j], itmax=1000)$conf
    D2.k.tau <- dist(lmds.k.tau[[i,j]])
    LC[i,j] <- LCMC(D1,D2.k.tau,Kp)$M.Kp.adj
    #print(c(i,j,LC[i,j]))
  }
}

ij.max <- arrayInd(which.max(LC),.dim=dim(LC))
k.max <- K[ij.max[1]] 
tau.max <- tau[ij.max[2]] 
lmds.max <- lmds.k.tau[[ij.max[1],ij.max[2]]]

print(paste0("k.max=",k.max,"; tau.max=",tau.max))
```

**Graphical representation of the Local MDS output.**
For the optimal $K$ and $\tau$, the output of the Local MDS is a $q$-dimensional configuration, that is, a $n\times q$ matrix (in our case with $q=1$).

We have called  `lmds.max` to this output. We can represent it graphically using the following instruction:

```{r}
pairs(cbind(XYZ,rt,locMDS=lmds.max[,1]))
```

Alternative graphical representations of the Local MDS fit, `lmds.max`, can be done using smoothing techniques:

```{r, fig.height=2,fig.width=7}
#install.packages("mgcv") # To perform spline smoothing
library(mgcv)

df.xyzts <- as.data.frame(cbind(XYZ,rt,locMDS=lmds.max[,1]))
names(df.xyzts)
#[1] "rx" "ry" "rz" "rt" "s(locMDS)" 

smooth.x <- gam(rx~s(locMDS), data=df.xyzts)
smooth.y <- gam(ry~s(locMDS), data=df.xyzts)
smooth.z <- gam(rz~s(locMDS), data=df.xyzts)

summary(smooth.x)
summary(smooth.y)
summary(smooth.z)

op <- par(mfrow=c(1,3))
plot(smooth.x, residuals=TRUE, shade=TRUE, cex=4, main="x versus locMDS")
plot(smooth.y, residuals=TRUE, shade=TRUE, cex=4, main="y versus locMDS")
plot(smooth.z, residuals=TRUE, shade=TRUE, cex=4, main="z versus locMDS")
par(op)
```
Now we do similar plots by ourselves:

```{r, fig.height=2,fig.width=7} 
s.x <- smooth.x$fitted.values
s.y <- smooth.y$fitted.values
s.z <- smooth.z$fitted.values
locMDS <- lmds.max[,1]

op <- par(mfrow=c(1,3))
plot(locMDS, rx, col=8, pch=19, cex=1, main="x versus locMDS")
lines(locMDS, s.x, col=1, lwd=2)
plot(locMDS, ry, col=8, pch=19, cex=1, main="y versus locMDS")
lines(locMDS, s.y, col=1, lwd=2)
plot(locMDS, rz, col=8, pch=19, cex=1, main="z versus locMDS")
lines(locMDS, s.z, col=1, lwd=2)
par(op)
```

We can add the nonlinear curve fitted by Local MDS to the 3-dimensional representation of the original data:

```{r}
require(plot3D)
lines3D(x,y,z,colvar = NULL, 
         phi = 20, theta = 60, r =sqrt(3), d =3, scale=FALSE,
         col=2,lwd=4,as=1,
         xlim=range(rx),ylim=range(ry),zlim=range(rz))
points3D(rx,ry,rz,col=4,pch=19,cex=.6,add=TRUE)
lines3D(s.x,s.y,s.z, col=1, lwd=4, add=TRUE)
```

And, finally, here you have a interactive 3-dimensional representation:
```{r}
require(rgl)
points3d(rx,ry,rz,col=4,size=10)
lines3d(x,y,z, col=2,lwd=4)
lines3d(s.x,s.y,s.z, col=1, lwd=4)
```