---
title: 'PCA: Example of ZIP numbers'
author: "Pedro Delicado"
date: "`r format(Sys.time(), '%d/%b/%Y')`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# ZIP numbers, from the book of Hastie et al. (2009)
#
# Data originally in
# https://web.stanford.edu/~hastie/ElemStatLearn/datasets/zip.train.gz
# https://web.stanford.edu/~hastie/ElemStatLearn/datasets/zip.test.gz
#
zip.train <- read.table("./03_nonlinear_dimensionality_reduction/zip.train")
dim(zip.train)
n<-dim(zip.train)[1]

zip.test <- read.table("./03_nonlinear_dimensionality_reduction/zip.test")
dim(zip.test)
```

```{r}
# ploting 1 digit
plot.zip <- function(x,use.first=FALSE){
  x<-as.numeric(x)
  if (use.first){
    x.mat <- matrix(x,16,16)
  }else{
    x.mat <- matrix(x[-1],16,16)
  }
  image(1:16,1:16,x.mat[,16:1],
        col=gray(seq(1,0,l=12)))
  if (!use.first) title(x[1])
  #col=gray(seq(1,0,l=2)))
}
```

```{r}
op <- par(mfrow=c(3,4))
apply(zip.train[sample(1:n,12),],1,plot.zip)
par(op)
```

```{r}
# perform PCA
zip.PC <- princomp(zip.train[,-1])
# displays a summary of the principal component analysis 
summary(zip.PC)
# creates a biplot, which is a type of graphical representation that combines a scatter plot of the data points with arrows 
# indicating the direction and strength of the loadings of the original variables on the principal components
biplot(zip.PC)
```

```{r}
# creates a scatter plot of the first and second principal components
plot(zip.PC$scores[,1:2],pch=19,cex=.5,col=zip.train[,1]+1) # colors the points based on the class labels in the first column
```

```{r}
# creates a scatter plot of the first and third principal components
plot(zip.PC$scores[,c(1,3)],pch=19,cex=.5,col=zip.train[,1]+1)
```

```{r}
#  creates a matrix of scatter plots for the first four principal components
pairs(zip.PC$scores[,1:4], pch=19,cex=.5,col=zip.train[,1]+1)
```

```{r}
# calculates the eigenvalues of the principal components
# eigenvalues represent the variance explained by each principal component
# zip.PC$sdev contains the standard deviations of the principal components, and squaring them yields the eigenvalues
eigvals <- zip.PC$sdev^2
# calculates the percentage of variance explained (VE) by each principal component
# sum of all eigenvalues (= total variance)
pctg.VE <- 100*eigvals/sum(eigvals)
# calculates the cumulative percentage of variance explained
cum.pctg.VE <- cumsum(pctg.VE) # cumulatively sum the percentages of variance explained from the first principal component to the current one

# displays the percentage of variance explained by the first 20 principal components
pctg.VE[1:20]
# Comp.1    Comp.2    Comp.3    Comp.4    Comp.5    Comp.6 
# 17.884424  8.967040  6.571727  5.554546  4.914189  3.851923 
# Comp.7    Comp.8    Comp.9   Comp.10   Comp.11   Comp.12 
# 3.271056  3.071029  2.566823  2.436703  2.177514  2.020786 
# Comp.13   Comp.14   Comp.15   Comp.16   Comp.17   Comp.18 
# 1.703614  1.469115  1.416223  1.298084  1.224955  1.152249 
# Comp.19   Comp.20 
# 1.060983  0.995179 

# displays the cumulative percentage of variance explained for the first 20 principal components
cum.pctg.VE[1:20]
# Comp.1   Comp.2   Comp.3   Comp.4   Comp.5   Comp.6   Comp.7 
# 17.88442 26.85146 33.42319 38.97774 43.89193 47.74385 51.01490 
# Comp.8   Comp.9  Comp.10  Comp.11  Comp.12  Comp.13  Comp.14 
# 54.08593 56.65276 59.08946 61.26697 63.28776 64.99137 66.46049 
# Comp.15  Comp.16  Comp.17  Comp.18  Comp.19  Comp.20 
# 67.87671 69.17480 70.39975 71.55200 72.61298 73.60816 

cum.pctg.VE[c(12,22,55,100)]
# Comp.12  Comp.22  Comp.55 Comp.100 
# 63.28776 75.49888 90.14044 96.01632 
k <- 12  # 63% varianza total
```

```{r}
# t(zip.PC$loadings[,1:12]) transposes the subset of the first 12 principal component loadings so that each row corresponds to one principal component
# apply plot.zip function to each row
op <- par(mfrow=c(3,4))
apply(t(zip.PC$loadings[,1:12]),1,plot.zip,use.first=TRUE)
par(op) 
```

```{r}
op <- par(mfrow=c(3,4))
for (j in 1:12){
  boxplot(zip.PC$scores[,j] ~ zip.train[,1])
  abline(h=0,col=2,lty=2)
}
par(op)
```

```{r}
# Interpreting the j-th PC with graphics of the form
#     mean +/- cte.j * PC_j
op<-par(mfrow=c(3,4))
zip.mean <- zip.PC$center
for (j in 1:k){
  plot.zip(zip.PC$loadings[,j], use.first=TRUE)
  title(paste("PC ",j,"; %VE=",round(pctg.VE[j],2)),col=3)
  cte.j <- quantile(abs(zip.PC$scores[,j]),.9)
  plot.zip(zip.mean - cte.j * zip.PC$loadings[,j], use.first=TRUE)
  title(paste("mean - cte.j * PC",j))
  plot.zip(zip.mean, use.first=TRUE)
  title("mean")
  plot.zip(zip.mean + cte.j * zip.PC$loadings[,j], use.first=TRUE)
  title(paste("mean + cte.j * PC",j))
}
par(op)
```

```{r}
# Approximation of an observation by the first k PCs:
# X_i \approx \bar{X} + \sum_{j=1}^k \psi_{ij} PC_j
i<-sample(n,1)
op<-par(mfrow=c(3,4))
plot.zip(zip.train[i,])
plot.zip(zip.mean,use.first = TRUE)
approx.zip.i <- zip.mean
for (j in 1:10){
  approx.zip.i <- approx.zip.i + zip.PC$scores[i,j]*zip.PC$loadings[,j]
  plot.zip(approx.zip.i,use.first = TRUE)
  title(paste("Up tp PC ",j))
}
par(op)
```

```{r}
# Approximation of an observation by the first k PCs:
# X_i \approx \bar{X} + \sum_{j=1}^k \psi_{ij} PC_j
i<-sample(n,1)
op<-par(mfrow=c(3,4))
plot.zip(zip.train[i,])
plot.zip(zip.mean,use.first = TRUE)
approx.zip.i <- zip.mean
for (j in c(1,2,3,5,10,20,50,100,150,200)){
  approx.zip.i <- zip.mean + 
    zip.PC$loadings[,1:j] %*% t(t(zip.PC$scores[i,1:j]))
  plot.zip(approx.zip.i,use.first = TRUE)
  title(paste("Up tp PC ",j))
}
par(op)
```