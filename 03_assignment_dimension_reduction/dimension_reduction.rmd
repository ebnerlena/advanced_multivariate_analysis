---
title: "Non-linear dimensionality reduction"
author: 'Group 1: Pariente Antonio, Bosch Guillem, Ebner Lena'
date: "`r format(Sys.time(), '%d/%m/%Y')`"
output:
  html_document: default
  pdf_document: default
editor_options: 
  markdown: 
    wrap: sentence
---

# Non-linear dimensionality reduction: Principal curves, local MDS, Isomap and t-SNE

## PART A. Principal curves

### 1. Choosing the smoothing parameter in Principal Curves (Hastie and Stuetzle 1989)

Consider the 3-dimensional data set generated by the following code.

```{r}
library(plot3D)
library(princurve)
```

```{r}
t <- seq(-1.5*pi,1.5*pi,l=100)
R<- 1
n<-75
sd.eps <- .15

set.seed(1)
y <- R*sign(t) - R*sign(t)*cos(t/R)
x <- -R*sin(t/R)
z <- (y/(2*R))^2
rt <- sort(runif(n)*3*pi - 1.5*pi)
eps <- rnorm(n)*sd.eps
ry <- R*sign(rt) - (R+eps)*sign(rt)*cos(rt/R)
rx <- -(R+eps)*sin(rt/R)
rz <- (ry/(2*R))^2 + runif(n,min=-2*sd.eps,max=2*sd.eps)
XYZ <- cbind(rx,ry,rz)


require(plot3D)
lines3D(x,y,z,colvar = NULL, 
         phi = 20, theta = 60, r =sqrt(3), d =3, scale=FALSE,
         col=2,lwd=4,as=1,
         xlim=range(rx),ylim=range(ry),zlim=range(rz))
points3D(rx,ry,rz,col=4,pch=19,cex=.6,add=TRUE)
```

When fitting principal curves to these data, use the function `princurve::principal_curve` with the following options:

-   `smoother="smooth_spline"`. This is the default, so you do not need to use it explicitely.
-   The only additional argument that you will pass to `smooth_spline` will be the degrees of freedom df (see `help(smooth.spline) if you want)

For instance, the following sentence

`principal_curve(XYZ, df=6)`

fits the required principal curve with degrees of freedom `df` equal to 6.

#### Questions

1.  Choose the value of the degrees of freedom `df` by leave-one-out cross-validation. Restrict the search of `df` to `seq(2,8,by=1)`. (Hint: The function `project_to_curve` should be used. See the element `dist` of the object it returns).

```{r}
loocv <- function(data,k){
  distance=0
  for(i in 1:dim(data)[1]){
    pred=princurve::principal_curve(data[-i,],df=k)
    pred_proj= princurve::project_to_curve(t(matrix(data[i,])),pred$s[pred$ord,])
    distance= distance + pred_proj$dist
  }
  return(distance)
}

K=seq(2,8,by=1)
distances=c()

for(k in K){
  distances=append(distances,loocv(XYZ,k))
}

min_k=K[which.min(distances)]
plot(K, distances)
abline(v=min_k,col=2)
```

2.  Give a graphical representation of the principal curve output for the optimal `df` and comment on the obtained results.

The principal curve with the optimal df=6 fits the data by going through it in an S-like shape. It captures the data trend without grasping the points.

```{r}
best_df <- min_k
best_pc_fit <- principal_curve(XYZ, df = best_df)

# Project your data onto the selected principal curve
projected_data <- project_to_curve(XYZ, best_pc_fit$s[best_pc_fit$ord, ])

# Assess the quality of the projection by examining the dist element
projection_distances <- best_pc_fit$dist

cat("Best df:", best_df, "\n")
cat("Projection Distances:", projection_distances, "\n")

plot(best_pc_fit,xlim=range(XYZ[,1]),ylim=range(XYZ[,2]),asp=1)
points(XYZ,col=4)

# 3D PLOT OF THE CURVE
curve_coords = best_pc_fit$s[best_pc_fit$ord,]
lines3D(curve_coords[,1],curve_coords[,2],curve_coords[,3],colvar = NULL, 
         phi = 30, theta = 60, r =sqrt(3), d =3, scale=FALSE,
         col=2,lwd=4,as=1,
         xlim=range(XYZ[,1]),ylim=range(XYZ[,2]),zlim=range(XYZ[,3]))
points3D(XYZ[,1],XYZ[,2],XYZ[,3],col=4,pch=19,cex=.6,add=TRUE)

```

3.  Compute the leave-one-out cross-validation error for `df=50` and compare it with the result corresponding to the optimal `df` value you found before.

-   Before fitting the principal curve with `df=50` and based only on the leave-one-out cross-validation error values, what value for `df` do you think that is better, the previous optimal one or `df=50`?
-   Fit now the principal curve with `df=50` and plot the fitted curve in the 3D scatterplot of the original points.
-   Now, what value of `df` do you prefer?
-   The overfitting with `df=50` is clear. Nevertheless leave-one-out cross-validation has not been able to detect this fact. Why do you think that `df=50` is given a so good value of leave-one-out cross-validation error?

```{r}
distance=loocv(XYZ,50)
cat("LOOCV for df=50: ", distance, "\n")
cat("LOOCV for optimal df=6:", distances[min_k])
```

**What value for `df` do you think that is better, the previous optimal one or `df=50`?** Without plotting the principal curve, the cross-validation error for `df=50` seems way better than the one for the optimal df.
It is very small and seems almost too small to be true.

```{r}
pred=princurve::principal_curve(XYZ,df=50)
lines3D(pred$s[,1],pred$s[,2],pred$s[,3],colvar = NULL, 
         phi = 20, theta = 60, r =sqrt(3), d =3, scale=FALSE,
         col=2,lwd=4,as=1,
         xlim=range(XYZ[,1]),ylim=range(XYZ[,2]),zlim=range(XYZ[,3]))
points3D(XYZ[,1],XYZ[,2],XYZ[,3],col=4,pch=19,cex=.6,add=TRUE)
```

**What value of `df` do you prefer?** When looking at the plot of the principal curve with `df=50` it is clear to see that the curve is totally overfitting on the data we generated and does not generalize well.
Because of that, we prefer our optimal `df=6`.

**Why do you think that `df=50` is given a so good value of leave-one-out cross-validation error?** By increasing the degrees of freedom in the principal curve, the curve becomes more flexible/a more complex model.
So, the model is able to capture noise in the data.
LOOCV is sensitive to variance in the data and a more flexible model may reduce the bias leading to a low LOOCV error, but it does not generalize well on new data.
LOOCV is not able to capture the overfitting because the principal curve with 50 degrees of freedom is very long and interpolates the data points, so the curve becomes dense in some way.
This makes the distance to the projections of external points to the curve smaller, thus making the LOOCV error closer to zero.

## Part B. Local MDS, ISOMAP and t-SNE

Consider the ZIP number data set, from the book of Hastie et al. (2009).
Read the training data set (in the file zip.train) and select only the ZEROs.

There are `n=1194` digits corresponding to ZEROs in the data set.

The following function plots a digit:

```{r}
zip.train <- read.table("zip.train")
data=zip.train[zip.train$V1==0,][,-1]
print(dim(data)[1])
```

```{r}
# ploting 1 digit
plot.zip <- function(x,use.first=FALSE,...){
  x<-as.numeric(x)
  if (use.first){
    x.mat <- matrix(x,16,16)
  }else{
    x.mat <- matrix(x[-1],16,16)
  }
  image(1:16,1:16,x.mat[,16:1],
        col=gray(seq(1,0,l=12)),...)
  invisible(
    if (!use.first){
      title(x[1])
    }else{
    }
  )  
  #col=gray(seq(1,0,l=2)))
}
```


<p>Here you have several examples of these ZERO digits:</p>

<p><img src="data:image/png;base64,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" width="672"/></p>

### 2. Local MDS for ZERO digits

You must apply Local MDS to reduce the dimensionality of this dataset using the function `lmds` from package `stops`.
You have to install the library `stops` from this link and then to attach the library:

```{r}
#if (!require(stops, quietly=TRUE, warn.conflicts=FALSE)){
#  install.packages("stops", repos="http://R-Forge.R-project.org",INSTALL_opts="--no-test-load")
#}

library(stops)
# help(lmds)
```

1.  Look for a 2-dimensional `(q=2)` configuration of the data using parameters `k=5` and `tau=0.05` in `lmds` function. Do the scatterplot of the obtained 2-dimensional configuration.

```{r}
x=dist(as.matrix(data))

n <- dim(x)[1]
k <- 5
tau <- .05
q <-2

conf <- stats::cmdscale(x, k=q)
zero <- lmds(as.matrix(x), init=conf, ndim=q, k=k, tau=tau, itmax = 1000)
```

```{r}
# op <- par(mfrow=c(2,1))
plot(zero$conf,as=1, main=paste0("Local MDS, k=",k,", tau=",tau))
# text(zero$conf[,1],zero$conf[,2],1:n,pos=3, cex=0.7)
text(zero$conf[,1],zero$conf[,2],rownames(data),pos=3, cex=0.7)
```


2.  In the previous scatterplot, select a few points (9 points, for instance) located in such a way that they cover the variability of all the points in the scatterplot. Then use the function `plot.zip` to plot the ZERO digits corresponding to the selected points. The images you are plotting should allow you to give an interpretation of the 2 coordinates obtained by Local MDS (observe how the shape of ZEROs changes when moving along each directions of the scatterplot).
By doing this we have seen that the second coordinate from local MDS represents how thick the line drawn is and the first coordinate represents if the circle is more horizontally deformed or vertically deformed.
```{r}
pos_names =  c("left_top",  "top",   "right_top", "left", "middle", "right",  "left_bot", "bot",  "right_bot")
sel_points = c("638",       "7290",  "5727",      "4808", "4465",   "737"  ,  "6795",     "5697", "3572")
op <- par(mfrow = c(3,3))
for (i in 1:9){
  plot.zip(main=pos_names[i],data[sel_points[i],],use.first = TRUE)
}
```

Another approach would be to detect 9 clusters in the data configuration obtained by local MDS and use the centroids as points for visualizing the numbers. But with this approach there is not a clear pattern visible as in the approach described above.

```{r}
# select 9 points that cover the variability by looking for 9 clusters over the data and using their centroids

k=kmeans(zero$conf,9)
plot(zero$conf, col = k$cluster, main="K-Means Clustering on Local MDS")
points(k$centers)
library(FNN)
```

```{r,multi.col=T,height=50}
points=get.knnx(zero$conf, k$centers, 1)
points_x1=names(sort(zero$conf[points$nn.index,][,1]))
layout(matrix(k$cluster[points_x1], nrow = 3, ncol = 3))

for (p in points_x1){
  plot.zip(main=k$cluster[p],data[p,],use.first = TRUE)
}
```

3.  Use the local continuity meta criteria to select the tuning parameters `k` and `τ` in Local MDS for ZERO digits. Then describe graphically the low dimensional configuration corresponding to the optimal parameters. Indication: As tentative values for k use `c(5,10,50)`, and for τ use `c(.1,.5,1)`.

```{r}
LCMC <- function(D1,D2,Kp){
  D1 <- as.matrix(D1)
  D2 <- as.matrix(D2)
  n <- dim(D1)[1]
  N.Kp.i <- numeric(n)
  for (i in 1:n){
    N1.i <- sort.int(D1[i,],index.return = TRUE)$ix[1:Kp]
    N2.i <- sort.int(D2[i,],index.return = TRUE)$ix[1:Kp]
    N.Kp.i[i] <- length(intersect(N1.i, N2.i))
  }
  N.Kp<-mean(N.Kp.i)
  M.Kp.adj <- N.Kp/Kp - Kp/(n-1)
  
  return(list(N.Kp.i=N.Kp.i, M.Kp.adj=M.Kp.adj))
}
```

```{r}
K <- c(5,10,50)
tau <- c(.1,.5,1)
n <- dim(x)[1]
q<-2
D1=x
Kp=10 # nearest neighbors how many are considered for each point

LC.lmds <- matrix(0,nrow=length(K),ncol=length(tau))
lmds <- array(vector("list",1),dim=dim(LC.lmds))
conf <- stats::cmdscale(x, k=q)

for (i in 1:length(K)){
  for (j in 1:length(tau)){
    lmds[[i,j]] <- lmds(as.matrix(x), init=conf, ndim=q, k=K[i], tau=tau[j], itmax=1000)$conf
    D2 <- dist(lmds[[i,j]])
    LC.lmds[i,j] <- LCMC(D1,D2,Kp)$M.Kp.adj
    #print(c(i,j,LC.lmds[i,j]))
  }
}

ij.max <- arrayInd(which.max(LC.lmds),.dim=dim(LC.lmds))
k.max <- K[ij.max[1]]
tau.max <- tau[ij.max[2]] 
lmds.max <- lmds[[ij.max[1],ij.max[2]]]
#lmds.max <- lmds(as.matrix(x), init=conf, ndim=q, k=5, tau=1, itmax=1000)$conf
```

```{r}
plot(K, LC.lmds[,1], type="b", main=paste0("K=",round(k.max,4)))
abline(v=k.max,col=2)

plot(tau, LC.lmds[,2], type="b", main=paste0("tau=",round(tau.max,4)))
abline(v=tau.max,col=2)
```

After using the LCMC we can observe below the optimal configuration from the given pull of parameters. When comparing it with the scatter plot from the previous configuration, we can see that the aggregation of points is more similar to a straight line. Data representations happen to be more dispersed among the first dimension, while second dimension range seems to be preserved. This means that the first and second dimension expose higher correlation.

```{r}
print(paste0("k.max=",k.max,"; tau.max=",tau.max))
plot(lmds.max,as=1, main=paste0("Local MDS, k=",k.max,", tau=",tau.max))
text(lmds.max[,1],lmds.max[,2],1:n,pos=3, cex=.7)

```

### 3. ISOMAP for ZERO digits

1.  Look for a 2-dimensional (q=2) configuration of the data using parameter k=5 in function `isomap` from package `vegan`. Do the scatterplot of the obtained 2-dimensional configuration.

```{r}
library(vegan)

x=dist(as.matrix(data))
q<-2
k <- 5

ismp <- isomap(x,ndim=q, k=k)
plot(ismp,n.col=3,main="Output of ISOMAP Algorithm")
text(ismp$points[,1],ismp$points[,2],rownames(data),pos=3, cex=.5)
```

2.  In the previous scatterplot, select a few points (9 points, for instance) located in such a way that they cover the variability of all the points in the scatterplot. Then use the function `plot.zip` to plot the ZERO digits corresponding to the selected points. The images you are plotting should allows you to give an interpretation of the 2 coordinates obtained by ISOMAP (observe how the shape of ZEROs changes when moving along each directions of the scatterplot).

In the following figure we can appreciate the relations between the coordinates defined by ISOMAP and the types of zeroes drawn. We can see that the ones with lower values for dimension 2 are the ones that have lines connecting them to the previous digit of the ZIP code. The ones with high value for dimension 2 are more round and less dense, with less painted pixels.

For the other dimension we can say that the zeros with high value are more round and large and the ones with low values are thin and tall.

It is also visible that the zeros with values around the 0 for dimension 2 are drawn with thick lines.

```{r}
pos_names =  c("left_top", "top",   "right_top", "left", "middle", "right",  "left_bot", "bot",  "right_bot")
sel_points = c("3422",      "5026",  "6989",      "7069", "4774",   "364"  ,  "6659",     "1126", "1884")
op <- par(mfrow = c(3,3))
for (i in 1:9){
  plot.zip(main=pos_names[i],data[sel_points[i],],use.first = TRUE)
}
```

3.  Use the local continuity meta criteria to select the tuning parameter k in ISOMAP for ZERO digits. Then describe graphically the low dimensional configuration corresponding to the optimal parameter. Indication: As tentative values for k use `c(5,10,50)`.

```{r, warning=FALSE}
library(vegan)

k_values <- c(5, 10, 50)
q=2
D1 <- dist(data)
LC.ismp <- numeric(length(k_values))

isomap_results <- vector("list",length(k_values))

for (i in 1:length(k_values)){
   k <- k_values[i]
   isomap_results[[i]] <- isomap(D1, ndim=q, k=k)
   dist_k <- dist(isomap_results[[i]]$points[,1:q])
   LC.ismp[i] <- LCMC(D1, dist_k, k)$M.Kp.adj
}

i_max <- which.max(LC.ismp)
k_max <- k_values[i_max]
isomap_max <- isomap_results[i_max]

plot(k_values, LC.ismp, type="b", main=paste0("K=",round(k_max,4)))
abline(v=k_max,col=2)
```

```{r}
best_k_isomap <- isomap(D1, ndim=q,  k=k_max)
pairs(cbind(data[,1:2] ,isomap=best_k_isomap$points[,1:2]), pch=20, main="Best ISOMAP output in 2-dim")

plot(best_k_isomap$points[,1], best_k_isomap$points[,2], pch=20, main="Best ISOMAP output in 2-dim", as=1)
text(best_k_isomap$points[,1], best_k_isomap$points[,2], rownames(data),pos=3, cex=.5)
```
To explain this low dimensional representation we will use the same method as before. Through this method we have seen that the vertical dimension is correlated with the density of the image, how black the zero is. The first dimension (the horizontal one) seems correlated with the roundness of the zero, being the round zeros the ones with larger values in this dimension.

```{r}
pos_names =  c("left_top", "top",   "right_top", "left", "middle", "right", "left_bot", "bot",  "right_bot")
sel_points = c("2695",     "5542",  "5911",      "6381", "5626",   "4964",  "6462",     "6890", "4898")
op <- par(mfrow = c(3,3))
for (i in 1:9){
  plot.zip(main=pos_names[i],data[sel_points[i],],use.first = TRUE)
}
```

### 4. t-SNE for ZERO digits

You must apply t-SNE to reduce the dimensionality of this dataset using the function Rtsne from package `Rtsne`.

```{r}
library(Rtsne)
# help(Rtsne)
```

1.  Look for a 2-dimensional (q=2) configuration of the data using parameters `perplexity=40` and `theta=0` in `Rtsne` function. Do the scatterplot of the obtained 2-dimensional configuration.

```{r}
x=dist(as.matrix(data))

set.seed(42)
theta= 0.0
perp = 40

tsne_out <- Rtsne(x, pca=FALSE, perplexity=perp, theta=theta)

plot(tsne_out$Y, asp=1, main="t-SNE on ZIP data")
text(tsne_out$Y[,1], tsne_out$Y[,2], rownames(data), pos = 3, cex = .7)
```

2.  In the previous scatterplot, select a few points (9 points, for instance) located in such a way that they cover the variability of all the points in the scatterplot. Then use the function `plot.zip` to plot the ZERO digits corresponding to the selected points. The images you are plotting should allows you to give an interpretation of the 2 coordinates obtained by t-SNE (observe how the shape of ZEROs changes when moving along each directions of the scatterplot).

Proceeding as before we see that the zeros at the bottom are the ones having deviations from the usual circle shape. These are the ones that have additional segments, when the line that defines the zero is longer than it should be so it has an external ramification. On the other side, at the top part of the plot there are the zeros whose circle is incomplete, that the line is too short. We could say that the other dimension is related to the vertical or horizontal deformation of the zero but it is not something very clear.

```{r}
pos_names =  c("left_top", "top",   "right_top", "left", "middle", "right", "left_bot", "bot",  "right_bot")
sel_points = c("5331",     "2001",  "4391",      "5819", "5333",   "4272",  "5532",     "4614", "6890")
op <- par(mfrow = c(3,3))
for (i in 1:9){
  plot.zip(main=pos_names[i],data[sel_points[i],],use.first = TRUE)
}
```

3.  Use the local continuity meta criteria to select the tuning parameter `perplexity` in t-SNE for ZERO digits (use q=2 and `theta`=0). Then describe graphically the low dimensional configuration corresponding to the optimal parameter. Indication: As tentative values for `perplexity` use `c(10,20,40)`.

```{r}
require(Rtsne)
set.seed(4444)

D1 <- dist(data)
Kp <- 10
q <- 2
theta = 0

perplexity <- c(10,20,40)

LC.tsne <- numeric(length(perplexity))
Rtsne.k <- vector("list",length(perplexity))

for (i in 1:length(perplexity)){
    Rtsne.k[[i]] <- Rtsne(D1, perplexity=perplexity[i], dims=q,
                          theta=0, pca=FALSE, max_iter = 1000)
    D2.k <- dist(Rtsne.k[[i]]$Y)
    LC.tsne[i] <- LCMC(D1,D2.k,Kp)$M.Kp.adj
}

i.max <- which.max(LC.tsne)
perplexity_max <- perplexity[i.max[1]] 
best_rtsne <- Rtsne.k[[i.max]]

plot(perplexity,LC.tsne, main=paste0("perplexity max=",perplexity_max))
abline(v=perplexity[i.max],col=2)
```

```{r}
pairs(cbind(data[,1:2] ,tsne=best_rtsne$Y[,1:2]), pch=20, main="Best t-SNE output in 2-dim")
```

### 4. Compare Local MDS, ISOMAP and t-SNE for ZERO digits

1.  Compare graphically the dimensions of the 2-dimensional configurations you have obtained by Local MDS, ISOMAP and t-SNE for ZERO digits. Indication: Use the function `pairs` applied to a 6-dimensional matrix.

With the following figure we see that the first dimension of the three dimensionality reduction methods that we have used is very similar. The plots between first dimensions from different methods show a clear correlation, close to the identity function (or minus the identity function) with some noise. The same effect is also present between the second dimensions of the Local MDS and the ISOMAP.

We can say that Local MDS and ISOMAP give very similar new dimensions, except for a sign.

For the t-SNE the resemblance with the other two second dimensions is not that clear. It is visible that there is a correlation but the noise in this case is way higher, since the scatterplots are not as close to a straight identity line.

```{r}
pairs(cbind(lmds1=lmds.max[,1], lmds2=lmds.max[,2],ismp1=best_k_isomap$points[,1],ismp2=best_k_isomap$points[,2],tsne1=best_rtsne$Y[,1],tsne2=best_rtsne$Y[,2]))
```

2.  Which method have produced the 2-dimensional configurations with the largest value of the local continuity meta criteria?

The method that has produced the largest value for LCMC is, by far, t-SNE.

```{r}
cat("local MDS: ",max(LC.lmds), "\n")
cat("ISOMAP: ",max(LC.ismp), "\n")
cat("t-SNE: ",max(LC.tsne),"\n")
```
