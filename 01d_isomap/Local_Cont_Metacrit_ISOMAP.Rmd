---
title: 'Choosing the tuning parameters in ISOMAP'
subtitle: 'Local Continuity Meta-criteria'
author: "Pedro Delicado"
date: "`r format(Sys.time(), '%d de %B de %Y')`"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval=TRUE, warning = FALSE, 
                      message = FALSE, comment = FALSE, error = FALSE)
#Put echo = FALSE, eval=FALSE for having just the question statements
#Put echo = TRUE, eval=TRUE for obtaining the output
```

## Local Continuity Meta-criteria

Chen and Buja (2009, JASA, Section 3) propose a criteria for tuning parameter selection in ISOMAP: The *Local Continuity Meta-criteria* (or *LC meta-criteria*) that is also useful for other dimensionality reduction methods.

Following the notation used in the classes slides, for a neighborhood size $K'$ and for the $i$-th object $\mathcal{O}_i$ in the data set, let $N_{K'}(i)$ be the number of cases that simultaneously are between the $K'$-nearest neighbors of $\mathcal{O}_i$ in the high-dimensional space (distances here are $\delta_{ij}$), and between the $K'$-nearest neighbors of the mapped point $y_i$ in the low-dimensional configuration (distances here are $\|y_i-y_j\|$). Then define
\[
N_{K'}=\frac{1}{n}\sum_{i=1}^n N_{K'}(i) 
\]
as a global measure of overlapping between $K'$-nearest neighbors in both spaces, that could be called *local continuity*.
In order to normalize, 
\[
M_{K'}=\frac{1}{K'} N_{K'}
\]
is used instead of $N_{K'}$ ($M_{K'}$ is always in $[0,1]$). Even better is using the *adjusted LC meta-criteria* defined as
\[
M_{K'}^{adj}=M_{K'} - \frac{K'}{n-1},
\]
because $K'/(n-1)$ is the expected value of $M_{K'}$ under complete absence of association between the original data and the low-dimensional configuration. 

The following function computes $M_{K'}^{adj}$ as a function of two distance matrices between points (one being computed in the high-dimensional space, an the other being the Euclidean distance matrix in the low-dimensional configuration) and the value $K'$.

```{r}
LCMC <- function(D1,D2,Kp){
  D1 <- as.matrix(D1)
  D2 <- as.matrix(D2)
  n <- dim(D1)[1]
  N.Kp.i <- numeric(n)
  for (i in 1:n){
    N1.i <- sort.int(D1[i,],index.return = TRUE)$ix[1:Kp]
    N2.i <- sort.int(D2[i,],index.return = TRUE)$ix[1:Kp]
    N.Kp.i[i] <- length(intersect(N1.i, N2.i))
  }
  N.Kp<-mean(N.Kp.i)
  M.Kp.adj <- N.Kp/Kp - Kp/(n-1)
  
  return(list(N.Kp.i=N.Kp.i, M.Kp.adj=M.Kp.adj))
}
```

## Generating the dataset

We are working with a 3-dimensional data set generated around a 1-dimensional S-shape curve. We use the following code to generate the data.

```{r, echo=TRUE, eval=TRUE}
t <- seq(-1.5*pi,1.5*pi,l=100)
R<- 1
n<-75
sd.eps <- .15

set.seed(1)
y <- R*sign(t) - R*sign(t)*cos(t/R)
x <- -R*sin(t/R)
z <- (y/(2*R))^2
rt <- sort(runif(n)*3*pi - 1.5*pi)
eps <- rnorm(n)*sd.eps
ry <- R*sign(rt) - (R+eps)*sign(rt)*cos(rt/R)
rx <- -(R+eps)*sin(rt/R)
rz <- (ry/(2*R))^2 + runif(n,min=-2*sd.eps,max=2*sd.eps)
XYZ <- cbind(rx,ry,rz)

require(plot3D)
lines3D(x,y,z,colvar = NULL, 
         phi = 20, theta = 60, r =sqrt(3), d =3, scale=FALSE,
         col=2,lwd=4,as=1,
         xlim=range(rx),ylim=range(ry),zlim=range(rz))
points3D(rx,ry,rz,col=4,pch=19,cex=.6,add=TRUE)
```

## Choosing the tuning parameters in ISOMAP

ISOMAP depends on two tuning parameters:

- $\varepsilon$ or $k$ that identifies the neighborhood relations:
  - When using $\varepsilon$, two objects $\mathcal{O}_i$ and $\mathcal{O}_j$ are 
 considered neighbors if 
 $\delta_{ij}=d(\mathcal{O}_i, \mathcal{O}_j)\le \varepsilon$.
  - When using $k$, two objects $\mathcal{O}_i$ and $\mathcal{O}_j$ are 
 considered neighbors if either $\mathcal{O}_i$ is among the $k$-nearest
neighbors of $\mathcal{O}_j$, or vice-versa. 
- $q$, the dimension of the desired low-dimensional configuration.

Here we fix $q=1$ and use $\varepsilon$ instead of $k$.


**Choosing the $\varepsilon$ maximizing the Local Continuity Meta-criteria.** 
We use $K'=10$ and restrict the search of $\varepsilon$ to `seq($d_0$,$d_1$,length=10)`, where $d_0$ and $d_1$ are the quantiles of orders $0.1$ and $0.25$, respectively, of the set $\{\delta_{ij}:i,j\}$ of distances between pairs of objects.


```{r}
D1 <- dist(XYZ)
d0 <- quantile(D1,.1)
d1 <- quantile(D1,.25)
# print(c(d0,d1))

q <- 1

Kp <- 10

v.epsilon <- seq(d0,d1,length=10)

LC <- numeric(length(v.epsilon))
ISOMAP.eps <- vector("list",length(v.epsilon))

library(vegan)
for (i in 1:length(v.epsilon)){
  ISOMAP.eps[[i]] <- isomap(D1, ndim=q, 
                            epsilon= v.epsilon[i])
  D2.eps <- dist(ISOMAP.eps[[i]]$points[,1:q])
  LC[i] <- LCMC(D1,D2.eps,Kp)$M.Kp.adj
  #print(c(i,j,LC[i,j]))
}


i.max <- which.max(LC)
epsilon.max <- v.epsilon[i.max]
ISOMAP.max <- ISOMAP.eps[[i.max]]

plot(v.epsilon, LC, type="b", main=paste0("epsilon.max=",round(epsilon.max,4)))
abline(v=epsilon.max,col=2)
```

**Graphical representation of the ISOMAP output.**
For the optimal $\varepsilon$, the output of the ISOMAP is a $q$-dimensional configuration, that is, a $n\times q$ matrix (in our case with $q=1$).

We have called  `ISOMAP.max` to this output. We can represent it graphically using the following instruction:

```{r}
pairs(cbind(XYZ,rt,lambda=ISOMAP.max$points[,1]))
```

Alternative graphical representations of the ISOMAP fit, `ISOMAP.max`, can be done using smoothing techniques:

```{r, fig.height=2,fig.width=7}
#install.packages("mgcv") # To perform spline smoothing
library(mgcv)

df.xyzts <- as.data.frame(cbind(XYZ,rt,lambda=ISOMAP.max$points[,1]))
names(df.xyzts)
#[1] "rx" "ry" "rz" "rt" "s(lambda)" 

smooth.x <- gam(rx~s(lambda), data=df.xyzts)
smooth.y <- gam(ry~s(lambda), data=df.xyzts)
smooth.z <- gam(rz~s(lambda), data=df.xyzts)

summary(smooth.x)
summary(smooth.y)
summary(smooth.z)

op <- par(mfrow=c(1,3))
plot(smooth.x, residuals=TRUE, shade=TRUE, cex=4, main="x versus lambda")
plot(smooth.y, residuals=TRUE, shade=TRUE, cex=4, main="y versus lambda")
plot(smooth.z, residuals=TRUE, shade=TRUE, cex=4, main="z versus lambda")
par(op)
```
Now we do similar plots by ourselves:

```{r, fig.height=2,fig.width=7} 
s.x <- smooth.x$fitted.values
s.y <- smooth.y$fitted.values
s.z <- smooth.z$fitted.values
lambda <- ISOMAP.max$points[,1]

op <- par(mfrow=c(1,3))
plot(lambda, rx, col=8, pch=19, cex=1, main="x versus lambda")
lines(lambda, s.x, col=1, lwd=2)
plot(lambda, ry, col=8, pch=19, cex=1, main="y versus lambda")
lines(lambda, s.y, col=1, lwd=2)
plot(lambda, rz, col=8, pch=19, cex=1, main="z versus lambda")
lines(lambda, s.z, col=1, lwd=2)
par(op)
```

We can add the nonlinear curve fitted by ISOMAP to the 3-dimensional representation of the original data:

```{r}
require(plot3D)
lines3D(x,y,z,colvar = NULL, 
         phi = 20, theta = 60, r =sqrt(3), d =3, scale=FALSE,
         col=2,lwd=4,as=1,
         xlim=range(rx),ylim=range(ry),zlim=range(rz))
points3D(rx,ry,rz,col=4,pch=19,cex=.6,add=TRUE)
lines3D(s.x,s.y,s.z, col=1, lwd=4, add=TRUE)
```

And, finally, here you have a interactive 3-dimensional representation:
```{r}
require(rgl)
points3d(rx,ry,rz,col=4,size=10)
lines3d(x,y,z, col=2,lwd=4)
lines3d(s.x,s.y,s.z, col=1, lwd=4)
```